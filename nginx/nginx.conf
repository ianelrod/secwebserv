
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    proxy_intercept_errors on;
    error_page 502 503 504 @error503; # always reply with 503

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;

    server {
        # We use named locations for handling errors so that we can prevent
        # NGiNX from converting the request method to GET for requests with
        # other methods (usually POST). See https://github.com/SpiderLabs/ModSecurity-nginx/issues/152

        # the error handlers may use the `error_page` directive internally
        # so we have to enable recursive error pages
        recursive_error_pages on;
        error_page 404 = @error404;
        error_page 410 = @error410;
        error_page 500 = @error500;
        error_page 503 504 = @error503;

        ## error handlers
        location @error404 {
            # internal 404 only occur for files and in that case we
            # don't need to return HTML to the client.

            # disable recursive error pages for the remainder of the request
            # or we'll end up in an infinite loop because we end up using
            # the same `error_page` directive over and over
            recursive_error_pages off;
            return 404;
        }
        location @error410 {
            if ($request_method = GET) {
                # override the directive from the outer scope
                error_page 410 /errors/gone.html;
                # now return the error status code, which will
                # trigger the `error_page` we just set
                return 410;
            }
            # disable recursive error pages for the remainder of the request
            # or we'll end up in an infinite loop because we end up using
            # the same `error_page` directive over and over
            recursive_error_pages off;
            # we already hit `error_page` once and now that we've disabled
            # recursive error pages this will return the response to the client
            return 410;
        }
        location @error500 {
            # see comments in @error410
            if ($request_method = GET) {
                error_page 500 /errors/internalservererror.html;
                return 500;
            }
            recursive_error_pages off;
            return 500;
        }
        location @error503 {
            # see comments in @error410
            if ($request_method = GET) {
                error_page 503 /errors/maintenance.html;
                return 503;
            }
            recursive_error_pages off;
            return 503;
        }

        # handles all error page requests
        location /errors {
            root ${error_root};
            internal;
        }
    }
}